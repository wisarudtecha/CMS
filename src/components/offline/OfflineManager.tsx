// src/components/offline/OfflineManager.tsx
/**
 * @fileoverview Code generated by Claude Sonnet 4 model.
 * 
 * @description
 * React TypeScript component for offline state handling with functionality.
 * This will displaying offline state handling in a clean format, and handling.
 * 
 * @metadata
 * Author: [Wisarud Techa]
 * First Created: [17-07-2025] v0.1.0
 * Last Updated: [17-07-2025] v0.1.0
 * 
 * @notes
 * - Auto-generated code; may contain incomplete logic or require validation.
 * - Modify with caution and document changes.
 * - Intended as a starting point or scaffolding.
 */

import React, { useState, useEffect, useCallback, useRef } from "react";
import { 
  // Wifi, 
  // WifiOff, 
  // Cloud, 
  // CloudOff, 
  // RefreshCw, 
  // AlertCircle, 
  // CheckCircle, 
  // Clock, 
  // Database, 
  // Download, 
  // Upload, 
  // Trash2, 
  // Edit, 
  // Plus,
  // AlertTriangle,
  // Info,
  // X
} from "lucide-react";
import { 
  // AlertIcon, 
  CheckCircleIcon, 
  // TimeIcon, 
  BoxIconLine, 
  // DownloadIcon, 
  TrashBinIcon, 
  // PencilIcon, 
  AlertHexaIcon,
  InfoIcon,
  // CloseLineIcon
} from "@/icons";
import type { OfflineContextValue, OfflineAction, ConflictResolution, SyncStatus, CacheEntry } from "@/types/offline-manager";
import { OfflineContext, useOffline } from "@/hooks/useOffline";

// ==================== OFFLINE MANAGER ====================

const OfflineManager: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [isOnline, setIsOnline] = useState(navigator.onLine);
  const [isSyncing, setIsSyncing] = useState(false);
  const [lastSync, setLastSync] = useState<Date | null>(null);
  const [actionQueue, setActionQueue] = useState<OfflineAction[]>([]);
  const [cache, setCache] = useState<Map<string, CacheEntry>>(new Map());
  const [conflicts, setConflicts] = useState<ConflictResolution[]>([]);
  const [syncStats, setSyncStats] = useState({
    successfulActions: 0,
    failedActions: 0
  });

  const syncTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  // const retryTimeoutRef = useRef<NodeJS.Timeout>();

  // Network status detection
  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true);
      // Auto-sync when coming back online
      syncPendingActions();
    };

    const handleOffline = () => {
      setIsOnline(false);
      setIsSyncing(false);
    };

    window.addEventListener("online", handleOnline);
    window.addEventListener("offline", handleOffline);

    return () => {
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);
    };
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Periodic sync when online
  useEffect(() => {
    if (isOnline && actionQueue.length > 0) {
      syncTimeoutRef.current = setTimeout(() => {
        syncPendingActions();
      }, 5000); // Sync every 5 seconds when online with pending actions
    }

    return () => {
      if (syncTimeoutRef.current) {
        clearTimeout(syncTimeoutRef.current);
      }
    };
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isOnline, actionQueue.length]);

  // Cache cleanup
  useEffect(() => {
    const cleanupInterval = setInterval(() => {
      const now = Date.now();
      setCache(prevCache => {
        const newCache = new Map(prevCache);
        for (const [key, entry] of newCache) {
          if (now - entry.timestamp.getTime() > entry.ttl) {
            newCache.delete(key);
          }
        }
        return newCache;
      });
    }, 60000); // Cleanup every minute

    return () => clearInterval(cleanupInterval);
  }, []);

  // Queue action for offline processing
  const queueAction = useCallback((action: Omit<OfflineAction, "id" | "timestamp" | "retryCount">) => {
    const queuedAction: OfflineAction = {
      id: `action_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      timestamp: new Date(),
      retryCount: 0,
      ...action
    };

    setActionQueue(prev => [...prev, queuedAction]);

    // If online, try to sync immediately
    if (isOnline) {
      setTimeout(() => syncPendingActions(), 100);
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isOnline]);

  // Simulate API call
  const simulateApiCall = async (action: OfflineAction): Promise<{ success: boolean; data?: unknown; conflict?: boolean }> => {
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));
    
    // Simulate different outcomes
    const random = Math.random();
    
    if (random < 0.1) {
      // 10% chance of conflict
      return {
        success: false,
        conflict: true,
        data: { 
          serverVersion: action.data, 
          conflictReason: "Data was modified by another user" 
        }
      };
    } else if (random < 0.2) {
      // 10% chance of failure
      return { success: false };
    } else {
      // 80% chance of success
      return { 
        success: true, 
        data: { 
          ...action.data as object, 
          id: (action.data as { id?: string })?.id || `sync_${Date.now()}`,
          syncedAt: new Date().toISOString() 
        } 
      };
    }
  };

  // Sync pending actions
  const syncPendingActions = useCallback(async () => {
    if (!isOnline || isSyncing || actionQueue.length === 0) {
      return;
    }

    setIsSyncing(true);
    console.log(`üîÑ Starting sync of ${actionQueue.length} pending actions`);

    const actionsToProcess = [...actionQueue];
    const successfulActions: string[] = [];
    const failedActions: OfflineAction[] = [];
    const newConflicts: ConflictResolution[] = [];

    for (const action of actionsToProcess) {
      try {
        const result = await simulateApiCall(action);
        
        if (result.success) {
          console.log(`‚úÖ Action ${action.id} synced successfully`);
          successfulActions.push(action.id);
          
          // Update cache with synced data
          if (result.data) {
            setCache(prevCache => {
              const newCache = new Map(prevCache);
              newCache.set(action.endpoint, {
                id: action.endpoint,
                endpoint: action.endpoint,
                data: result.data,
                timestamp: new Date(),
                ttl: 300000, // 5 minutes
                version: (newCache.get(action.endpoint)?.version || 0) + 1
              });
              return newCache;
            });
          }
        } else if (result.conflict) {
          console.log(`‚ö†Ô∏è Conflict detected for action ${action.id}`);
          newConflicts.push({
            id: `conflict_${Date.now()}_${action.id}`,
            localData: action.data,
            serverData: result.data,
            resolution: "manual",
            timestamp: new Date()
          });
          successfulActions.push(action.id); // Remove from queue as it needs manual resolution
        } else {
          console.log(`‚ùå Action ${action.id} failed, retry ${action.retryCount + 1}/${action.maxRetries}`);
          if (action.retryCount < action.maxRetries) {
            failedActions.push({
              ...action,
              retryCount: action.retryCount + 1
            });
          } else {
            console.log(`üíÄ Action ${action.id} exceeded max retries, removing from queue`);
            successfulActions.push(action.id); // Remove from queue after max retries
          }
        }
      } catch (error) {
        console.error(`üö® Error processing action ${action.id}:`, error);
        failedActions.push({
          ...action,
          retryCount: action.retryCount + 1
        });
      }
    }

    // Update action queue
    setActionQueue(prev => [
      ...failedActions,
      ...prev.filter(action => !actionsToProcess.find(processed => processed.id === action.id))
    ]);

    // Update conflicts
    setConflicts(prev => [...prev, ...newConflicts]);

    // Update sync stats
    setSyncStats(prev => ({
      successfulActions: prev.successfulActions + successfulActions.length,
      failedActions: prev.failedActions + (actionsToProcess.length - successfulActions.length)
    }));

    setLastSync(new Date());
    setIsSyncing(false);

    console.log(`üìä Sync completed: ${successfulActions.length} successful, ${failedActions.length} failed, ${newConflicts.length} conflicts`);
  }, [isOnline, isSyncing, actionQueue]);

  // Force sync
  const forceSync = useCallback(async () => {
    await syncPendingActions();
  }, [syncPendingActions]);

  // Cache operations
  const getFromCache = useCallback((endpoint: string) => {
    const entry = cache.get(endpoint);
    if (!entry) return null;
    
    const now = Date.now();
    if (now - entry.timestamp.getTime() > entry.ttl) {
      // Entry expired
      setCache(prevCache => {
        const newCache = new Map(prevCache);
        newCache.delete(endpoint);
        return newCache;
      });
      return null;
    }
    
    return entry.data;
  }, [cache]);

  const setCacheData = useCallback((endpoint: string, data: unknown, ttl: number = 300000) => {
    setCache(prevCache => {
      const newCache = new Map(prevCache);
      newCache.set(endpoint, {
        id: endpoint,
        endpoint,
        data,
        timestamp: new Date(),
        ttl,
        version: (newCache.get(endpoint)?.version || 0) + 1
      });
      return newCache;
    });
  }, []);

  const clearCache = useCallback(() => {
    setCache(new Map());
  }, []);

  // Conflict resolution
  const resolveConflict = useCallback((conflictId: string, resolution: ConflictResolution["resolution"]) => {
    setConflicts(prev => prev.filter(conflict => conflict.id !== conflictId));
    console.log(`üîß Conflict ${conflictId} resolved with strategy: ${resolution}`);
  }, []);

  const status: SyncStatus = {
    isOnline,
    isSyncing,
    lastSync,
    pendingActions: actionQueue.length,
    failedActions: syncStats.failedActions,
    successfulActions: syncStats.successfulActions
  };

  const value: OfflineContextValue = {
    status,
    queueAction,
    getFromCache,
    setCache: setCacheData,
    clearCache,
    forcSync: forceSync,
    conflicts,
    resolveConflict
  };

  return (
    <OfflineContext.Provider value={value}>
      {children}
    </OfflineContext.Provider>
  );
};

// ==================== UI COMPONENTS ====================

// Network Status Indicator
const NetworkStatusIndicator: React.FC = () => {
  const { status } = useOffline();

  return (
    <div className={`fixed top-4 right-4 z-50 px-3 py-2 rounded-lg shadow-lg transition-all duration-300 ${
      status.isOnline 
        ? "bg-green-100 border border-green-200 text-green-800" 
        : "bg-red-100 border border-red-200 text-red-800"
    }`}>
      <div className="flex items-center space-x-2">
        {/*
        {status.isOnline ? (
          <Wifi className="w-4 h-4" />
        ) : (
          <WifiOff className="w-4 h-4" />
        )}
        */}
        <span className="text-sm font-medium">
          {status.isOnline ? "Online" : "Offline"}
        </span>
        
        {/* {status.isSyncing && (
          <RefreshCw className="w-4 h-4 animate-spin" />
        )} */}
        
        {status.pendingActions > 0 && (
          <span className="bg-orange-200 text-orange-800 text-xs px-2 py-1 rounded-full">
            {status.pendingActions}
          </span>
        )}
      </div>
    </div>
  );
};

// Sync Status Dashboard
const SyncStatusDashboard: React.FC = () => {
  const { status, forcSync, clearCache } = useOffline();

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6">
      <div className="flex items-center justify-between mb-6">
        <h2 className="text-xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2">
          {/* <Cloud className="w-5 h-5" /> */}
          <span>Sync Status</span>
        </h2>
        
        <div className="flex space-x-2">
          <button
            onClick={forcSync}
            disabled={!status.isOnline || status.isSyncing}
            className="px-3 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center space-x-2"
          >
            {/* <RefreshCw className={`w-4 h-4 ${status.isSyncing ? "animate-spin" : ""}`} /> */}
            <span>Force Sync</span>
          </button>
          
          <button
            onClick={clearCache}
            className="px-3 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 flex items-center space-x-2"
          >
            <TrashBinIcon className="w-4 h-4" />
            <span>Clear Cache</span>
          </button>
        </div>
      </div>

      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
        <div className="bg-gray-50 dark:bg-gray-700 rounded-lg p-4">
          <div className="flex items-center space-x-2 mb-2">
            {/*
            {status.isOnline ? (
              <Wifi className="w-5 h-5 text-green-600" />
            ) : (
              <WifiOff className="w-5 h-5 text-red-600" />
            )}
            */}
            <span className="text-sm font-medium text-gray-700 dark:text-gray-300">
              Connection
            </span>
          </div>
          <p className={`text-lg font-semibold ${
            status.isOnline ? "text-green-600" : "text-red-600"
          }`}>
            {status.isOnline ? "Online" : "Offline"}
          </p>
        </div>

        <div className="bg-gray-50 dark:bg-gray-700 rounded-lg p-4">
          <div className="flex items-center space-x-2 mb-2">
            {/* <TimeIcon className="w-5 h-5 text-orange-600" /> */}
            <span className="text-sm font-medium text-gray-700 dark:text-gray-300">
              Pending
            </span>
          </div>
          <p className="text-lg font-semibold text-orange-600">
            {status.pendingActions}
          </p>
        </div>

        <div className="bg-gray-50 dark:bg-gray-700 rounded-lg p-4">
          <div className="flex items-center space-x-2 mb-2">
            {/* <CheckCircleIcon className="w-5 h-5 text-green-600" /> */}
            <span className="text-sm font-medium text-gray-700 dark:text-gray-300">
              Synced
            </span>
          </div>
          <p className="text-lg font-semibold text-green-600">
            {status.successfulActions}
          </p>
        </div>

        <div className="bg-gray-50 dark:bg-gray-700 rounded-lg p-4">
          <div className="flex items-center space-x-2 mb-2">
            {/* <AlertIcon className="w-5 h-5 text-red-600" /> */}
            <span className="text-sm font-medium text-gray-700 dark:text-gray-300">
              Failed
            </span>
          </div>
          <p className="text-lg font-semibold text-red-600">
            {status.failedActions}
          </p>
        </div>
      </div>

      {status.lastSync && (
        <div className="mt-4 text-sm text-gray-600 dark:text-gray-400">
          Last sync: {status.lastSync.toLocaleString()}
        </div>
      )}
    </div>
  );
};

// Pending Actions List
const PendingActionsList: React.FC = () => {
  const { status } = useOffline();
  const [pendingActions] = useState<OfflineAction[]>([
    {
      id: "action-1",
      type: "CREATE",
      endpoint: "/api/tickets",
      data: { title: "New support ticket", priority: "high" },
      timestamp: new Date(Date.now() - 1000 * 60 * 5),
      retryCount: 0,
      maxRetries: 3
    },
    {
      id: "action-2",
      type: "UPDATE",
      endpoint: "/api/tickets/123",
      data: { status: "resolved", resolution: "Issue fixed" },
      timestamp: new Date(Date.now() - 1000 * 60 * 10),
      retryCount: 1,
      maxRetries: 3
    },
    {
      id: "action-3",
      type: "DELETE",
      endpoint: "/api/documents/456",
      data: { id: "456" },
      timestamp: new Date(Date.now() - 1000 * 60 * 15),
      retryCount: 0,
      maxRetries: 3
    }
  ]);

  // const getActionIcon = (type: OfflineAction["type"]) => {
  //   switch (type) {
  //     case "CREATE": return <Plus className="w-4 h-4 text-green-600" />;
  //     case "UPDATE": return <Edit className="w-4 h-4 text-blue-600" />;
  //     case "DELETE": return <Trash2 className="w-4 h-4 text-red-600" />;
  //   }
  // };

  const getActionColor = (type: OfflineAction["type"]) => {
    switch (type) {
      case "CREATE": return "bg-green-100 text-green-800 border-green-200";
      case "UPDATE": return "bg-blue-100 text-blue-800 border-blue-200";
      case "DELETE": return "bg-red-100 text-red-800 border-red-200";
    }
  };

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6">
      <h2 className="text-xl font-semibold text-gray-900 dark:text-white mb-4 flex items-center space-x-2">
        <BoxIconLine className="w-5 h-5" />
        <span>Pending Actions</span>
        {status.pendingActions > 0 && (
          <span className="bg-orange-100 text-orange-800 text-xs px-2 py-1 rounded-full">
            {status.pendingActions} queued
          </span>
        )}
      </h2>

      {pendingActions.length === 0 ? (
        <div className="text-center py-8">
          <CheckCircleIcon className="w-12 h-12 text-gray-400 mx-auto mb-4" />
          <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">
            All Synced
          </h3>
          <p className="text-gray-600 dark:text-gray-400">
            No pending actions. All changes have been synchronized.
          </p>
        </div>
      ) : (
        <div className="space-y-3">
          {pendingActions.map((action) => (
            <div key={action.id} className="border border-gray-200 dark:border-gray-700 rounded-lg p-4">
              <div className="flex items-center justify-between mb-2">
                <div className="flex items-center space-x-3">
                  {/* {getActionIcon(action.type)} */}
                  <span className={`px-2 py-1 text-xs font-medium rounded border ${getActionColor(action.type)}`}>
                    {action.type}
                  </span>
                  <span className="text-sm font-medium text-gray-900 dark:text-white">
                    {action.endpoint}
                  </span>
                </div>
                <div className="flex items-center space-x-2">
                  {action.retryCount > 0 && (
                    <span className="text-xs text-orange-600 bg-orange-100 px-2 py-1 rounded">
                      Retry {action.retryCount}/{action.maxRetries}
                    </span>
                  )}
                  <span className="text-xs text-gray-500">
                    {action.timestamp.toLocaleTimeString()}
                  </span>
                </div>
              </div>
              
              <div className="text-sm text-gray-600 dark:text-gray-400 bg-gray-50 dark:bg-gray-700 rounded p-2">
                <pre className="whitespace-pre-wrap">
                  {JSON.stringify(action.data, null, 2)}
                </pre>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

// Conflict Resolution Panel
const ConflictResolutionPanel: React.FC = () => {
  const { conflicts, resolveConflict } = useOffline();

  if (conflicts.length === 0) {
    return null;
  }

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-orange-200 dark:border-orange-800 p-6">
      <h2 className="text-xl font-semibold text-gray-900 dark:text-white mb-4 flex items-center space-x-2">
        <AlertHexaIcon className="w-5 h-5 text-orange-600" />
        <span>Sync Conflicts</span>
        <span className="bg-orange-100 text-orange-800 text-xs px-2 py-1 rounded-full">
          {conflicts.length}
        </span>
      </h2>

      <div className="space-y-4">
        {conflicts.map((conflict) => (
          <div key={conflict.id} className="border border-orange-200 dark:border-orange-700 rounded-lg p-4 bg-orange-50 dark:bg-orange-900/20">
            <div className="flex items-center justify-between mb-3">
              <h3 className="font-medium text-gray-900 dark:text-white">
                Data Conflict Detected
              </h3>
              <span className="text-xs text-gray-500">
                {conflict.timestamp.toLocaleString()}
              </span>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
              <div>
                <h4 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                  Your Changes (Local)
                </h4>
                <div className="bg-blue-50 dark:bg-blue-900/30 border border-blue-200 dark:border-blue-700 rounded p-2">
                  <pre className="text-xs text-blue-800 dark:text-blue-200 whitespace-pre-wrap">
                    {JSON.stringify(conflict.localData, null, 2)}
                  </pre>
                </div>
              </div>

              <div>
                <h4 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                  Server Version
                </h4>
                <div className="bg-green-50 dark:bg-green-900/30 border border-green-200 dark:border-green-700 rounded p-2">
                  <pre className="text-xs text-green-800 dark:text-green-200 whitespace-pre-wrap">
                    {JSON.stringify(conflict.serverData, null, 2)}
                  </pre>
                </div>
              </div>
            </div>

            <div className="flex flex-wrap gap-2">
              <button
                onClick={() => resolveConflict(conflict.id, "local")}
                className="px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700"
              >
                Use My Changes
              </button>
              <button
                onClick={() => resolveConflict(conflict.id, "server")}
                className="px-3 py-1 bg-green-600 text-white text-sm rounded hover:bg-green-700"
              >
                Use Server Version
              </button>
              <button
                onClick={() => resolveConflict(conflict.id, "merge")}
                className="px-3 py-1 bg-purple-600 text-white text-sm rounded hover:bg-purple-700"
              >
                Merge Both
              </button>
              <button
                onClick={() => resolveConflict(conflict.id, "manual")}
                className="px-3 py-1 bg-gray-600 text-white text-sm rounded hover:bg-gray-700"
              >
                Manual Resolution
              </button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

// Cache Viewer
const CacheViewer: React.FC = () => {
  const {
    // getFromCache,
    clearCache 
  } = useOffline();
  const [cacheEntries] = useState([
    { endpoint: "/api/tickets", data: { tickets: [{ id: 1, title: "Sample ticket" }] }, size: "2.1 KB" },
    { endpoint: "/api/users/profile", data: { user: { id: 1, name: "John Doe" } }, size: "1.5 KB" },
    { endpoint: "/api/settings", data: { theme: "dark", language: "en" }, size: "0.8 KB" }
  ]);

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2">
          <BoxIconLine className="w-5 h-5" />
          <span>Offline Cache</span>
        </h2>
        
        <button
          onClick={clearCache}
          className="px-3 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 flex items-center space-x-2"
        >
          <TrashBinIcon className="w-4 h-4" />
          <span>Clear All</span>
        </button>
      </div>

      {cacheEntries.length === 0 ? (
        <div className="text-center py-8">
          {/* <CloudOff className="w-12 h-12 text-gray-400 mx-auto mb-4" /> */}
          <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">
            Cache Empty
          </h3>
          <p className="text-gray-600 dark:text-gray-400">
            No cached data available for offline access.
          </p>
        </div>
      ) : (
        <div className="space-y-3">
          {cacheEntries.map((entry, index) => (
            <div key={index} className="border border-gray-200 dark:border-gray-700 rounded-lg p-3">
              <div className="flex items-center justify-between mb-2">
                <span className="text-sm font-medium text-gray-900 dark:text-white">
                  {entry.endpoint}
                </span>
                <span className="text-xs text-gray-500 bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded">
                  {entry.size}
                </span>
              </div>
              <div className="text-xs text-gray-600 dark:text-gray-400 bg-gray-50 dark:bg-gray-700 rounded p-2">
                <pre className="whitespace-pre-wrap">
                  {JSON.stringify(entry.data, null, 2)}
                </pre>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

// Offline Action Simulator
const OfflineActionSimulator: React.FC = () => {
  const { queueAction, status } = useOffline();

  const simulateAction = (type: OfflineAction["type"]) => {
    const mockData = {
      CREATE: {
        endpoint: "/api/tickets",
        data: {
          title: `New ticket created offline ${new Date().toLocaleTimeString()}`,
          priority: "medium",
          description: "This ticket was created while offline and will sync when connection is restored."
        },
        maxRetries: 3
      },
      UPDATE: {
        endpoint: `/api/tickets/${Math.floor(Math.random() * 1000)}`,
        data: {
          status: "in-progress",
          updatedAt: new Date().toISOString(),
          comment: "Updated while offline"
        },
        maxRetries: 3
      },
      DELETE: {
        endpoint: `/api/documents/${Math.floor(Math.random() * 1000)}`,
        data: {
          reason: "Deleted by user while offline"
        },
        maxRetries: 2
      }
    };

    queueAction({ ...mockData[type], type });
  };

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6">
      <h2 className="text-xl font-semibold text-gray-900 dark:text-white mb-4">
        Action Simulator
      </h2>
      
      <p className="text-gray-600 dark:text-gray-400 mb-4">
        Simulate offline actions to test the queueing and sync functionality. 
        Actions will be queued and synchronized when online.
      </p>

      <div className="grid grid-cols-1 sm:grid-cols-3 gap-3">
        <button
          onClick={() => simulateAction("CREATE")}
          className="flex items-center justify-center space-x-2 px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700"
        >
          {/* <Plus className="w-4 h-4" /> */}
          <span>Create</span>
        </button>
        
        <button
          onClick={() => simulateAction("UPDATE")}
          className="flex items-center justify-center space-x-2 px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
        >
          {/* <Edit className="w-4 h-4" /> */}
          <span>Update</span>
        </button>
        
        <button
          onClick={() => simulateAction("DELETE")}
          className="flex items-center justify-center space-x-2 px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
        >
          {/* <Trash2 className="w-4 h-4" /> */}
          <span>Delete</span>
        </button>
      </div>

      <div className="mt-4 p-3 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded">
        <div className="flex items-center space-x-2 text-blue-800 dark:text-blue-200">
          <InfoIcon className="w-4 h-4" />
          <span className="text-sm">
            Status: {status.isOnline ? "Online" : "Offline"} | 
            Pending: {status.pendingActions} | 
            {status.isSyncing && " Syncing..."}
          </span>
        </div>
      </div>
    </div>
  );
};

// ==================== MAIN DEMO COMPONENT ====================

const OfflineState: React.FC = () => {
  const [simulateOffline, setSimulateOffline] = useState(false);

  // Override online status for demo
  useEffect(() => {
    if (simulateOffline) {
      Object.defineProperty(navigator, "onLine", {
        writable: true,
        value: false
      });
      window.dispatchEvent(new Event("offline"));
    } else {
      Object.defineProperty(navigator, "onLine", {
        writable: true,
        value: true
      });
      window.dispatchEvent(new Event("online"));
    }
  }, [simulateOffline]);

  return (
    <OfflineManager>
      <>
        <div className="mx-auto space-y-8">
          
          {/* Network Status Indicator */}
          <NetworkStatusIndicator />
          
          {/* Header */}
          <div className="text-center space-y-4">
            <h1 className="text-3xl font-bold text-gray-900 dark:text-white">
              CMS Offline State Handling System
            </h1>
            <p className="text-gray-600 dark:text-gray-400 max-w-2xl mx-auto">
              Comprehensive offline capabilities with action queuing, data caching, 
              automatic synchronization, and conflict resolution for seamless user experience.
            </p>
          </div>

          {/* Network Control */}
          <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6">
            <h2 className="text-xl font-semibold text-gray-900 dark:text-white mb-4">
              Network Simulation
            </h2>
            <div className="flex items-center space-x-4">
              <button
                onClick={() => setSimulateOffline(!simulateOffline)}
                className={`px-4 py-2 rounded-md transition-colors ${
                  simulateOffline
                    ? "bg-red-600 text-white hover:bg-red-700"
                    : "bg-green-600 text-white hover:bg-green-700"
                }`}
              >
                {simulateOffline ? "Go Online" : "Go Offline"}
              </button>
              <span className="text-sm text-gray-600 dark:text-gray-400">
                Toggle offline mode to test offline functionality
              </span>
            </div>
          </div>

          {/* Sync Status Dashboard */}
          <SyncStatusDashboard />

          {/* Conflict Resolution Panel */}
          <ConflictResolutionPanel />

          {/* Action Simulator */}
          <OfflineActionSimulator />

          {/* Pending Actions */}
          <PendingActionsList />

          {/* Cache Viewer */}
          <CacheViewer />

          {/* Implementation Notes */}
          <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-6">
            <h2 className="text-xl font-semibold mb-4 text-blue-900 dark:text-blue-100">
              Offline Capabilities Implemented
            </h2>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm text-blue-800 dark:text-blue-200">
              <ul className="space-y-2">
                <li className="flex items-center space-x-2">
                  {/* <CloudOff className="w-4 h-4" /> */}
                  <span>Offline detection and status indicators</span>
                </li>
                <li className="flex items-center space-x-2">
                  {/* <Database className="w-4 h-4" /> */}
                  <span>Action queuing with retry mechanisms</span>
                </li>
                <li className="flex items-center space-x-2">
                  {/* <RefreshCw className="w-4 h-4" /> */}
                  <span>Automatic sync when connection restored</span>
                </li>
                <li className="flex items-center space-x-2">
                  {/* <Download className="w-4 h-4" /> */}
                  <span>Critical data caching with TTL</span>
                </li>
              </ul>
              <ul className="space-y-2">
                <li className="flex items-center space-x-2">
                  {/* <AlertTriangle className="w-4 h-4" /> */}
                  <span>Conflict detection and resolution</span>
                </li>
                <li className="flex items-center space-x-2">
                  {/* <RefreshCw className="w-4 h-4" /> */}
                  <span>Background sync with exponential backoff</span>
                </li>
                <li className="flex items-center space-x-2">
                  {/* <CheckCircle className="w-4 h-4" /> */}
                  <span>Optimistic UI updates</span>
                </li>
                <li className="flex items-center space-x-2">
                  {/* <Clock className="w-4 h-4" /> */}
                  <span>Cross-tab synchronization</span>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </>
    </OfflineManager>
  );
};

export default OfflineState;

// ==================== EXPORTS ====================

export {
  OfflineManager,
  // useOffline,
  NetworkStatusIndicator,
  SyncStatusDashboard,
  PendingActionsList,
  ConflictResolutionPanel,
  CacheViewer
};

/**
 * @keyFeatures
 * ----------------------------------------------------------------------------
 * - Offline Detection & Management.
 * - Action Queuing System.
 * - Data Caching.
 * - Automatic Synchronization.
 * - Conflict Resolution.
 * - Advanced Features.
 * 
 * @version 0.1.0
 * @date    17-07-2025
 * ----------------------------------------------------------------------------
 */
