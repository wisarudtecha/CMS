// /src/components/builder/FlowEditor.tsx
/**
 * @fileoverview Code generated by Claude Sonnet 4 model.
 * 
 * @description
 * Visual workflow builder with drag-and-drop functionality, node connections, and configuration panels.
 * Since react-flow isn't available in this environment.
 * 
 * @metadata
 * Author: [Wisarud Techa]
 * First Created: [11-06-2025] v0.1.0
 * Last Updated: [16-06-2025] v0.1.3
 * 
 * @notes
 * - Auto-generated code; may contain incomplete logic or require validation.
 * - Modify with caution and document changes.
 * - Intended as a starting point or scaffolding.
 */

import
  React,
  {
    useCallback,
    useEffect,
    useRef,
    useState
  }
from 'react';
import PageBreadcrumb from "../../components/common/PageBreadCrumb";
import PageMeta from "../../components/common/PageMeta";
import Input from "../../components/form/input/InputField";
import Select from "../../components/form/Select";
import TextArea from "../../components/form/input/TextArea";
import Alert from "../../components/ui/alert/Alert";
import Button from "../../components/ui/button/Button";
import { Modal } from "../../components/ui/modal";
import {
  CheckLineIcon,
  CopyIcon,
  DownloadIcon,
  FileIcon,
  PencilIcon,
  TrashBinIcon
} from "../../icons";

// TypeScript interfaces
interface Position {
  x: number;
  y: number;
}

interface WorkflowNode {
  id: string;
  type: 'start' | 'process' | 'decision' | 'end';
  position: Position;
  data: {
    label: string;
    description?: string;
    config?: Record<string, unknown>;
  };
}

interface Connection {
  id: string;
  source: string;
  target: string;
  sourceHandle?: string;
  targetHandle?: string;
  // Updated: [16-06-2025] v0.1.3
  label?: string; // For Yes/No labels
}

interface WorkflowData {
  nodes: WorkflowNode[];
  connections: Connection[];
  // Updated: [12-06-2025] v0.1.2
  metadata: {
    title: string;
    description: string;
    status: 'draft' | 'active' | 'inactive' | 'testing';
    createdAt?: string;
    updatedAt?: string;
  };
}

interface WorkflowEditorProps {
  initialData?: WorkflowData;
  // Updated: [16-06-2025] v0.1.3
  workflowId?: string; // For loading from URL
  onSave?: (data: WorkflowData) => void;
}

// Updated: [12-06-2025] v0.1.1
// Grid configuration
const GRID_SIZE = 20;
const NODE_WIDTH = 96; // 24 * 4 (w-24)
const NODE_HEIGHT = 64; // 16 * 4 (h-16)

// Updated: [12-06-2025] v0.1.2
// Workflow status options
const workflowStatuses = [
  { value: 'draft', label: 'Draft', color: 'text-gray-600 dark:text-gray-300 bg-gray-100 dark:bg-gray-800' },
  { value: 'active', label: 'Active', color: 'text-green-600 dark:text-green-300 bg-green-100 dark:bg-green-800' },
  { value: 'inactive', label: 'Inactive', color: 'text-red-600 dark:text-red-300 bg-red-100 dark:bg-red-800' },
  { value: 'testing', label: 'Testing', color: 'text-blue-600 dark:text-blue-300 bg-blue-100 dark:bg-blue-800' }
] as const;

// Node type configurations
const nodeTypes = {
  start: { color: 'bg-green-500 dark:bg-green-400', label: 'Start' },
  process: { color: 'bg-blue-500 dark:bg-blue-400', label: 'Process' },
  decision: { color: 'bg-yellow-500 dark:bg-yellow-400', label: 'Decision' },
  end: { color: 'bg-red-500 dark:bg-red-400', label: 'End' }
};

const WorkflowVisualEditor: React.FC<WorkflowEditorProps> = ({ 
  initialData = {
    nodes: [],
    connections: [],
    metadata: {
      title: 'Untitled Workflow',
      description: '',
      status: 'draft',
      createdAt: new Date().toISOString()
    }
  },
  // Updated: [16-06-2025] v0.1.3
  workflowId,
  onSave 
}) => {
  const [nodes, setNodes] = useState<WorkflowNode[]>(initialData.nodes);
  const [connections, setConnections] = useState<Connection[]>(initialData.connections);
  const [selectedNode, setSelectedNode] = useState<WorkflowNode | null>(null);
  const [isDragging, setIsDragging] = useState<string | null>(null);
  const [dragOffset, setDragOffset] = useState<Position>({ x: 0, y: 0 });
  const [isConnecting, setIsConnecting] = useState<string | null>(null);
  const [tempConnection, setTempConnection] = useState<Position | null>(null);
  const svgRef = useRef<SVGSVGElement>(null);
  const canvasRef = useRef<HTMLDivElement>(null);

  // Updated: [12-06-2025] v0.1.1
  const [showJsonPreview, setShowJsonPreview] = useState<boolean>(false);
  // Updated: [12-06-2025] v0.1.2
  const [workflowMetadata, setWorkflowMetadata] = useState(initialData.metadata);
  // Updated: [16-06-2025] v0.1.3
  const [connectingFrom, setConnectingFrom] = useState<'yes' | 'no' | null>(null);
  const [validationErrors, setValidationErrors] = useState<string[]>([]);
  const [copiedJson, setCopiedJson] = useState<boolean>(false);

  const threeLayerBreadcrumb = [
    { label: "Home", href: "/" },
    { label: "Workflows", href: "/workflows" },
    { label: "Workflow Builder" },
  ];

  const actionOptions = [
    { value: "new", label: "New" },
    { value: "disp", label: "Dispatching" },
    { value: "accept", label: "Accept" },
    { value: "arrival", label: "Arrival" },
    { value: "resolve", label: "Resolve" },
    { value: "complete", label: "Complete" },
    { value: "alert", label: "Email" },
    { value: "assign", label: "Assign Vender" },
    { value: "fix", label: "Fix" }
  ];

  // Updated: [16-06-2025] v0.1.3
  const formOptions = [
    { value: "new", label: "Form - New" },
    { value: "disp", label: "Form - Dispatching" },
    { value: "accept", label: "Button - Accept" },
    { value: "arrival", label: "Button - Arrival" },
    { value: "resolve", label: "Button - Resolve" },
    { value: "complete", label: "Button - Complete" },
    { value: "alert", label: "Toast - Email" },
    { value: "assign", label: "Select - Assign Vender" },
    { value: "fix", label: "Form - Fix" }
  ];

  // Updated: [16-06-2025] v0.1.3
  const PICOptions = [
    { value: "admin", label: "Administrator" },
    { value: "agent", label: "Agent" },
    { value: "dispatcher", label: "Dispatcher" },
    { value: "responder", label: "Responder" },
    { value: "supervisor", label: "Supervisor" },
  ];

  // Updated: [12-06-2025] v0.1.2
  // Prepare workflow status options for Select component
  const workflowStatusesOptions = workflowStatuses.map(status => ({
    value: status.value,
    label: status.label
  }));

  // Updated: [16-06-2025] v0.1.3
  // Load workflow data from URL if workflowId is provided
  useEffect(() => {
    if (workflowId && workflowId !== 'new') {
      // Mock API call - replace with actual API
      const loadWorkflowFromUrl = async () => {
        try {
          // Simulate API call
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Mock workflow data - replace with actual API call
          const mockWorkflowData = {
            nodes: [
              {
                id: 'start-1',
                type: 'start' as const,
                position: { x: 100, y: 200 },
                data: { label: 'Start Process', description: 'Workflow entry point' }
              },
              {
                id: 'process-1',
                type: 'process' as const,
                position: { x: 300, y: 200 },
                data: { 
                  label: 'Review Application',
                  description: 'Review submitted application',
                  config: {
                    action: 'review_application',
                    form: 'application_form',
                    sla: '24',
                    pic: 'john_doe'
                  }
                }
              },
              {
                id: 'decision-1',
                type: 'decision' as const,
                position: { x: 500, y: 200 },
                data: { 
                  label: 'Approve?',
                  description: 'Decision to approve or reject',
                  config: { condition: 'application.score > 70' }
                }
              },
              {
                id: 'end-1',
                type: 'end' as const,
                position: { x: 700, y: 200 },
                data: { label: 'End Process', description: 'Workflow completion' }
              }
            ],
            connections: [
              { id: 'conn-1', source: 'start-1', target: 'process-1' },
              { id: 'conn-2', source: 'process-1', target: 'decision-1' },
              { id: 'conn-3', source: 'decision-1', target: 'end-1', label: 'yes' }
            ],
            metadata: {
              title: `Workflow ${workflowId}`,
              description: 'Loaded from URL',
              status: 'active' as const,
              createdAt: '2025-06-01T10:00:00Z'
            }
          };
          
          setNodes(mockWorkflowData.nodes);
          setConnections(mockWorkflowData.connections);
          setWorkflowMetadata(mockWorkflowData.metadata);
        } catch (error) {
          console.error('Failed to load workflow:', error);
        }
      };
      
      loadWorkflowFromUrl();
    }
  }, [workflowId]);

  // Updated: [16-06-2025] v0.1.3
  // Validate workflow before saving
  const validateWorkflow = useCallback((): string[] => {
    const errors: string[] = [];
    
    const hasStartNode = nodes.some(node => node.type === 'start');
    const hasEndNode = nodes.some(node => node.type === 'end');
    
    if (!hasStartNode) {
      errors.push('Workflow must have at least one Start node');
    }
    
    if (!hasEndNode) {
      errors.push('Workflow must have at least one End node');
    }
    
    // Validate connection limits
    const connectionCounts = nodes.reduce((acc, node) => {
      const outgoingConnections = connections.filter(conn => conn.source === node.id);
      acc[node.id] = outgoingConnections.length;
      return acc;
    }, {} as Record<string, number>);
    
    nodes.forEach(node => {
      const count = connectionCounts[node.id] || 0;
      if ((node.type === 'start' || node.type === 'process' || node.type === 'end') && count > 1) {
        errors.push(`${node.data.label} can only have 1 outgoing connection`);
      }
      if (node.type === 'decision' && count > 2) {
        errors.push(`${node.data.label} can only have 2 outgoing connections (Yes/No)`);
      }
    });
    
    return errors;
  }, [nodes, connections]);

  // Updated: [12-06-2025] v0.1.1
  // Snap position to grid
  const snapToGrid = useCallback((position: Position): Position => {
    return {
      x: Math.round(position.x / GRID_SIZE) * GRID_SIZE,
      y: Math.round(position.y / GRID_SIZE) * GRID_SIZE
    };
  }, []);

  // Updated: [12-06-2025] v0.1.1
  // Calculate connection point on node border
  const getNodeConnectionPoint = useCallback((fromPos: Position, toPos: Position, isSource: boolean): Position => {
    const nodeCenter = {
      x: (isSource ? fromPos.x : toPos.x) + NODE_WIDTH / 2,
      y: (isSource ? fromPos.y : toPos.y) + NODE_HEIGHT / 2
    };
    
    const otherCenter = {
      x: (isSource ? toPos.x : fromPos.x) + NODE_WIDTH / 2,
      y: (isSource ? toPos.y : fromPos.y) + NODE_HEIGHT / 2
    };

    // Calculate direction vector
    // const dx = otherCenter.x - nodeCenter.x;
    // const dy = otherCenter.y - nodeCenter.y;
    
    // Calculate intersection with node border (rectangle)
    // const absAngle = Math.atan2(Math.abs(dy), Math.abs(dx));
    // const nodeHalfWidth = NODE_WIDTH / 2;
    // const nodeHalfHeight = NODE_HEIGHT / 2;
    
    // let borderX, borderY;
    
    // Determine which edge of the rectangle the line intersects
    // if (absAngle < Math.atan2(nodeHalfHeight, nodeHalfWidth)) {
      // Intersects left or right edge
      // borderX = nodeCenter.x + (dx > 0 ? nodeHalfWidth : -nodeHalfWidth);
      // borderY = nodeCenter.y + (dy * nodeHalfWidth) / Math.abs(dx);
    // }
    // else {
      // Intersects top or bottom edge
      // borderX = nodeCenter.x + (dx * nodeHalfHeight) / Math.abs(dy);
      // borderY = nodeCenter.y + (dy > 0 ? nodeHalfHeight : -nodeHalfHeight);
    // }

    // return snapToGrid({ x: borderX, y: borderY });

    // Updated: [16-06-2025] v0.1.3
    // Calculate which side to connect from/to
    const dx = otherCenter.x - nodeCenter.x;
    const dy = otherCenter.y - nodeCenter.y;
    
    const nodeHalfWidth = NODE_WIDTH / 2;
    const nodeHalfHeight = NODE_HEIGHT / 2;
    
    // Determine connection side based on direction
    if (Math.abs(dx) > Math.abs(dy)) {
      // Horizontal connection (left/right)
      return {
        x: nodeCenter.x + (dx > 0 ? nodeHalfWidth : -nodeHalfWidth),
        y: nodeCenter.y
      };
    } else {
      // Vertical connection (top/bottom)
      return {
        x: nodeCenter.x,
        y: nodeCenter.y + (dy > 0 ? nodeHalfHeight : -nodeHalfHeight)
      };
    }
  }, [
    // Updated: [16-06-2025] v0.1.3
    // snapToGrid
  ]);

  // Add new node
  const addNode = useCallback((type: WorkflowNode['type']) => {
    const newNode: WorkflowNode = {
      id: `node-${Date.now()}`,
      type,
      // position: { x: 200, y: 200 },

      // Updated: [16-06-2025] v0.1.3
      position: snapToGrid({ x: 200, y: 200 }),

      data: {
        label: `${nodeTypes[type].label} ${nodes.length + 1}`,
        description: '',
        config: {}
      }
    };
    setNodes(prev => [...prev, newNode]);
  }, [
    nodes.length,

    // Updated: [16-06-2025] v0.1.3
    snapToGrid
  ]);

  // Handle mouse down on node
  const handleNodeMouseDown = useCallback((e: React.MouseEvent, nodeId: string) => {
    e.stopPropagation();
    const node = nodes.find(n => n.id === nodeId);
    if (!node) {
      return;
    }

    if (e.shiftKey) {
      // Shift + click to start connection

      // Updated: [16-06-2025] v0.1.3
      // Check connection limits
      const outgoingConnections = connections.filter(conn => conn.source === nodeId);
      const maxConnections = node.type === 'decision' ? 2 : 1;
      
      if (outgoingConnections.length >= maxConnections) {
        alert(`${node.type === 'decision' ? 'Decision' : 'This'} node already has maximum connections`);
        return;
      }
      
      // For decision nodes, determine Yes/No connection
      if (node.type === 'decision') {
        const hasYes = outgoingConnections.some(conn => conn.label === 'yes');
        const hasNo = outgoingConnections.some(conn => conn.label === 'no');
        
        if (!hasYes) {
          setConnectingFrom('yes');
        }
        else if (!hasNo) {
          setConnectingFrom('no');
        }
        else {
          alert('Decision node already has both Yes and No connections');
          return;
        }
      }
      else {
        setConnectingFrom(null);
      }

      setIsConnecting(nodeId);
    }
    else {
      // Regular click to drag
      const rect = canvasRef.current?.getBoundingClientRect();
      if (rect) {
        setIsDragging(nodeId);
        setDragOffset({
          x: e.clientX - rect.left - node.position.x,
          y: e.clientY - rect.top - node.position.y
        });
      }
    }
    setSelectedNode(node);
  }, [
    nodes,

    // Updated: [16-06-2025] v0.1.3
    connections
  ]);

  // Handle mouse move
  const handleMouseMove = useCallback((e: React.MouseEvent) => {
    const rect = canvasRef.current?.getBoundingClientRect();
    if (!rect) {
      return;
    }

    const mousePos = {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };

    if (isDragging) {
      const newPosition = snapToGrid({
        x: mousePos.x - dragOffset.x,
        y: mousePos.y - dragOffset.y
      });

      setNodes(prev => prev.map(node => 
        node.id === isDragging
          // ? { ...node, position: { x: mousePos.x - dragOffset.x, y: mousePos.y - dragOffset.y } }

          // Updated: [12-06-2025] v0.1.1
          ? { ...node, position: newPosition }
          : node
      ));
    }
    else if (isConnecting) {
      // Updated: [12-06-2025] v0.1.1
      setTempConnection(snapToGrid(mousePos));
    }
  }, [
    isDragging,
    isConnecting,
    dragOffset,

    // Updated: [12-06-2025] v0.1.1
    snapToGrid
  ]);

  // Handle mouse up
  const handleMouseUp = useCallback((e: React.MouseEvent) => {
    if (isConnecting) {
      // Check if we're over a node
      const target = e.target as Element;
      const nodeElement = target.closest('[data-node-id]');
      if (nodeElement) {
        const targetNodeId = nodeElement.getAttribute('data-node-id');
        if (targetNodeId && targetNodeId !== isConnecting) {
          // const newConnection: Connection = {
          //   id: `connection-${Date.now()}`,
          //   source: isConnecting,
          //   target: targetNodeId
          // };
          // setConnections(prev => [...prev, newConnection]);

          // Updated: [16-06-2025] v0.1.3
          // Validate connection
          const targetNode = nodes.find(n => n.id === targetNodeId);
          const sourceNode = nodes.find(n => n.id === isConnecting);
          
          if (targetNode && sourceNode) {
            // Check if target can accept connections (start nodes cannot be targets)
            if (targetNode.type === 'start') {
              alert('Cannot connect to Start node');
              setIsConnecting(null);
              setConnectingFrom(null);
              setTempConnection(null);
              return;
            }
            
            // Check for duplicate connections
            const existingConnection = connections.find(conn => 
              conn.source === isConnecting && conn.target === targetNodeId
            );
            
            if (existingConnection) {
              alert('Connection already exists');
              setIsConnecting(null);
              setConnectingFrom(null);
              setTempConnection(null);
              return;
            }
            
            const newConnection: Connection = {
              id: `connection-${Date.now()}`,
              source: isConnecting,
              target: targetNodeId,
              label: connectingFrom || undefined
            };
            setConnections(prev => [...prev, newConnection]);
          }
        }
      }
      setIsConnecting(null);

      // Updated: [16-06-2025] v0.1.3 
      setConnectingFrom(null);

      setTempConnection(null);
    }
    setIsDragging(null);
  }, [
    isConnecting,

    // Updated: [16-06-2025] v0.1.3
    connectingFrom,
    nodes,
    connections
  ]);

  // Delete node
  const deleteNode = useCallback((nodeId: string) => {
    setNodes(prev => prev.filter(n => n.id !== nodeId));
    setConnections(prev => prev.filter(c => c.source !== nodeId && c.target !== nodeId));
    if (selectedNode?.id === nodeId) {
      setSelectedNode(null);
    }
  }, [selectedNode]);

  // Update node data
  const updateNodeData = useCallback((nodeId: string, updates: Partial<WorkflowNode['data']>) => {
    setNodes(prev => prev.map(node => 
      node.id === nodeId 
        ? { ...node, data: { ...node.data, ...updates } }
        : node
    ));
    if (selectedNode?.id === nodeId) {
      setSelectedNode(prev => prev ? { ...prev, data: { ...prev.data, ...updates } } : null);
    }
  }, [selectedNode]);

  // Updated: [16-06-2025] v0.1.3
  // Copy JSON to clipboard
  const copyJsonToClipboard = useCallback(async () => {
    const workflowData = {
      nodes,
      connections,
      metadata: {
        ...workflowMetadata,
        updatedAt: new Date().toISOString()
      }
    };
    
    try {
      await navigator.clipboard.writeText(JSON.stringify(workflowData, null, 2));
      setCopiedJson(true);
      setTimeout(() => setCopiedJson(false), 2000);
    }
    catch (err) {
      console.error('Failed to copy to clipboard:', err);
    }
  }, [nodes, connections, workflowMetadata]);

  // Save workflow
  const saveWorkflow = useCallback(() => {
    // Updated: [16-06-2025] v0.1.3
    const errors = validateWorkflow();
    setValidationErrors(errors);

    if (errors.length > 0) {
      return; // Don't save if there are validation errors
    }

    const workflowData: WorkflowData = {
      nodes,
      connections,
      // Updated: [12-06-2025] v0.1.2
      metadata: {
        ...workflowMetadata,
        updatedAt: new Date().toISOString()
      }
    };
    onSave?.(workflowData);

    // Updated: [12-06-2025] v0.1.1
    setShowJsonPreview(false);

    console.log('Workflow saved:', workflowData);
  }, [
    nodes,
    connections,
    // onSave,

    // Updated: [12-06-2025] v0.1.2
    workflowMetadata,

    // Updated: [16-06-2025] v0.1.3
    onSave,
    validateWorkflow
  ]);

  // Updated: [12-06-2025] v0.1.2
  // Update workflow metadata
  const updateWorkflowMetadata = useCallback((updates: Partial<typeof workflowMetadata>) => {
    setWorkflowMetadata(prev => ({ ...prev, ...updates }));
  }, []);

  // Updated: [12-06-2025] v0.1.1
  // Show JSON preview before save
  const handleSaveClick = useCallback(() => {
    // Updated: [16-06-2025] v0.1.3
    const errors = validateWorkflow();
    setValidationErrors(errors);

    setShowJsonPreview(true);
  }, [
    // Updated: [16-06-2025] v0.1.3
    validateWorkflow,
  ]);

  // Get node center position
  // const getNodeCenter = useCallback((nodeId: string): Position => {
  //   const node = nodes.find(n => n.id === nodeId);
  //   return node ? { x: node.position.x + 60, y: node.position.y + 30 } : { x: 0, y: 0 };
  // }, [nodes]);

  // Updated: [12-06-2025] v0.1.1
  // Get node position by ID
  const getNodePosition = useCallback((nodeId: string): Position => {
    const node = nodes.find(n => n.id === nodeId);
    return node ? node.position : { x: 0, y: 0 };
  }, [nodes]);

  return (
    <>
      <PageMeta
        title="React.js Workflow Builder | TailAdmin - Next.js Admin Dashboard Template"
        description="This is React.js Workflow Builder page for TailAdmin - React.js Tailwind CSS Admin Dashboard Template"
      />

      <PageBreadcrumb items={threeLayerBreadcrumb} />

      <div className="flex h-screen bg-gray-50 dark:bg-gray-700 rounded-2xl border border-gray-200 dark:border-gray-700">
        {/* Toolbar */}
        <div className="w-64 bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 p-4 rounded-l-2xl">
          {/* Updated: [12-06-2025] v0.1.2 */}
          {/* Workflow Metadata */}
          <div className="mb-6">
            <h3 className="text-lg font-semibold text-gray-700 dark:text-gray-200 mb-2">Workflow Details</h3>
            
            {/* Title Input */}
            <div className="mb-3">
              <label className="block text-xs font-medium text-gray-700 dark:text-gray-200 mb-1">
                Title
              </label>
              <Input
                type="text"
                value={workflowMetadata.title}
                onChange={(e) => updateWorkflowMetadata({ title: e.target.value })}
                placeholder="Enter workflow title..."
              />
            </div>

            {/* Description Input */}
            <div className="mb-3">
              <label className="block text-xs font-medium text-gray-700 dark:text-gray-200 mb-1">
                Description
              </label>
              <TextArea
                value={workflowMetadata.description}
                // onChange={(e) => updateWorkflowMetadata({ description: e.target.value })}
                onChange={(value) => updateWorkflowMetadata({ description: value })}
                rows={2}
                placeholder="Brief description..."
              />
            </div>

            {/* Status Selector */}
            <div className="mb-3">
              <label className="block text-xs font-medium text-gray-700 dark:text-gray-200 mb-1">
                Status
              </label>
              <Select
                // defaultValue={workflowMetadata.status}
                value={workflowMetadata.status}
                // onChange={(e) => updateWorkflowMetadata({ status: e.target.value as any })}
                // onChange={(e) => updateWorkflowMetadata({ status: (e.target.value as WorkflowData['metadata']['status']) })}
                onChange={(value) => updateWorkflowMetadata({ status: (value as WorkflowData['metadata']['status']) })}
                options={workflowStatusesOptions}
                placeholder="Select Status"
              />
            </div>

            {/* Status Badge */}
            <div className="flex items-center gap-2">
              <span className="text-xs text-gray-500 dark:text-gray-400">Current Status:</span>
              <span className={`px-2 py-1 rounded-full text-xs font-medium ${
                workflowStatuses.find(s => s.value === workflowMetadata.status)?.color || 'text-gray-600 dark:text-gray-300 bg-gray-100 dark:bg-gray-800'
              }`}>
                {workflowStatuses.find(s => s.value === workflowMetadata.status)?.label}
              </span>
            </div>
          </div>

          {/* Node Types */}
          <div className="mb-6">
            <h3 className="text-lg font-semibold text-gray-700 dark:text-gray-200 mb-2">Add Nodes</h3>
            <div className="grid grid-cols-2 gap-2">
              {Object.entries(nodeTypes).map(([type, config]) => {
                return (
                  <Button
                    key={type}
                    onClick={() => addNode(type as WorkflowNode['type'])}
                    variant="outline"
                  >
                    <span className="text-gray-700 dark:text-gray-200">{config.label}</span>
                  </Button>
                );
              })}
            </div>
          </div>

          {/* Actions */}
          <div className="mb-6">
            <Button
              onClick={handleSaveClick}
              className="w-full mb-2"
              variant="primary"
            >
              <DownloadIcon className="w-4 h-4" />
              Save Workflow
            </Button>

            {/* Updated: [12-06-2025] v0.1.1 */}
            <Button
              onClick={() => setShowJsonPreview(true)}
              className="w-full"
              variant="outline"
            >
              <FileIcon className="w-4 h-4" />
              Preview Data
            </Button>
          </div>

          {/* Instructions */}
          <div className="text-xs text-gray-600 dark:text-gray-300 space-y-1">
            <p>• Click to select nodes</p>
            <p>• Drag to move nodes</p>
            <p>• Shift+click to connect nodes</p>
            {/* <p>• Configure selected node below</p> */}

            {/* Updated: [16-06-2025] v0.1.3 */}
            <p>• Decision nodes have Yes/No connectors</p>
            <p>• Start/End nodes required for save</p>
            <p>• Max connections: 1 (normal), 2 (decision)</p>
            <p>• Preview JSON before saving</p>
          </div>
        </div>

        {/* Canvas */}
        <div className="flex-1 relative">
          <div
            ref={canvasRef}
            className="w-full h-full overflow-hidden cursor-grab active:cursor-grabbing"
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
          >
            <svg
              ref={svgRef}
              className="absolute inset-0 w-full h-full pointer-events-none"
              style={{ zIndex: 1 }}
            >
              {/* Grid Pattern */}
              <defs>
                {/*
                <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                  <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#e5e7eb" strokeWidth="1"/>
                </pattern>
                */}
                {/* Updated: [12-06-2025] v0.1.1 */}
                <pattern id="grid" width={GRID_SIZE} height={GRID_SIZE} patternUnits="userSpaceOnUse">
                  <path d={`M ${GRID_SIZE} 0 L 0 0 0 ${GRID_SIZE}`} fill="none" stroke="#e5e7eb" strokeWidth="1"/>
                </pattern>
              </defs>
              <rect width="100%" height="100%" fill="url(#grid)" />

              {/* Connections */}
              {connections.map(connection => {
                // const sourcePos = getNodeCenter(connection.source);
                // const targetPos = getNodeCenter(connection.target);
                // const midX = (sourcePos.x + targetPos.x) / 2;
                // Updated: [12-06-2025] v0.1.1
                const sourcePos = getNodePosition(connection.source);
                const targetPos = getNodePosition(connection.target);
                const sourcePoint = getNodeConnectionPoint(sourcePos, targetPos, true);
                const targetPoint = getNodeConnectionPoint(sourcePos, targetPos, false);
                // const midX = (sourcePos.x + targetPos.x) / 2;

                // Updated: [16-06-2025] v0.1.3
                // Determine if connection is vertical (straight line) or horizontal (curve)
                const isVertical = Math.abs(sourcePoint.x - targetPoint.x) < 10;
                
                let pathD;
                if (isVertical) {
                  // Straight line for vertical connections
                  pathD = `M ${sourcePoint.x},${sourcePoint.y} L ${targetPoint.x},${targetPoint.y}`;
                } else {
                  // Curved line for horizontal connections
                  const midX = (sourcePoint.x + targetPoint.x) / 2;
                  pathD = `M ${sourcePoint.x},${sourcePoint.y} C ${midX},${sourcePoint.y} ${midX},${targetPoint.y} ${targetPoint.x},${targetPoint.y}`;
                }
                
                // Calculate label position
                const labelX = (sourcePoint.x + targetPoint.x) / 2;
                const labelY = (sourcePoint.y + targetPoint.y) / 2;
                
                return (
                  <g key={connection.id}>
                    <path
                      // d={`M ${sourcePos.x},${sourcePos.y} C ${midX},${sourcePos.y} ${midX},${targetPos.y} ${targetPos.x},${targetPos.y}`}

                      // Updated: [12-06-2025] v0.1.1
                      // d={`M ${sourcePoint.x},${sourcePoint.y} C ${midX},${sourcePoint.y} ${midX},${targetPoint.y} ${targetPoint.x},${targetPoint.y}`}

                      // Updated: [16-06-2025] v0.1.3
                      d={pathD}

                      // stroke="#6b7280"
                      stroke="#cccccc"
                      strokeWidth="2"
                      fill="none"
                      markerEnd="url(#arrowhead)"
                    />

                    {/* Updated: [16-06-2025] v0.1.3 */}
                    {connection.label && (
                      <g>
                        <circle
                          cx={labelX}
                          cy={labelY}
                          r="12"
                          fill="white"
                          stroke="#6b7280"
                          strokeWidth="1"
                        />
                        <text
                          x={labelX}
                          y={labelY}
                          textAnchor="middle"
                          dominantBaseline="central"
                          fontSize="10"
                          fill="#374151"
                          fontWeight="bold"
                        >
                          {connection.label === 'yes' ? 'Y' : 'N'}
                        </text>
                      </g>
                    )}
                  </g>
                );
              })}

              {/* Temporary connection while dragging */}
              {isConnecting && tempConnection && (
                // <path
                //   // d={`M ${getNodeCenter(isConnecting).x},${getNodeCenter(isConnecting).y} L ${tempConnection.x},${tempConnection.y}`}

                //   // Updated: [12-06-2025] v0.1.1
                //   d={`M ${getNodeConnectionPoint(getNodePosition(isConnecting), tempConnection, true).x},${getNodeConnectionPoint(getNodePosition(isConnecting), tempConnection, true).y} L ${tempConnection.x},${tempConnection.y}`}
                  
                //   stroke="#3b82f6"
                //   strokeWidth="2"
                //   strokeDasharray="5,5"
                //   fill="none"
                // />

                // Updated: [16-06-2025] v0.1.3
                <g>
                  <path
                    d={`M ${getNodeConnectionPoint(getNodePosition(isConnecting), tempConnection, true).x},${getNodeConnectionPoint(getNodePosition(isConnecting), tempConnection, true).y} L ${tempConnection.x},${tempConnection.y}`}
                    stroke="#3b82f6"
                    strokeWidth="2"
                    strokeDasharray="5,5"
                    fill="none"
                  />
                  {connectingFrom && (
                    <text
                      x={tempConnection.x + 10}
                      y={tempConnection.y - 10}
                      fontSize="12"
                      fill="#3b82f6"
                      fontWeight="bold"
                    >
                      {connectingFrom.toUpperCase()}
                    </text>
                  )}
                </g>
              )}

              {/* Arrow marker */}
              <defs>
                <marker
                  id="arrowhead"
                  markerWidth="10"
                  markerHeight="7"
                  refX="10"
                  refY="3.5"
                  orient="auto"
                >
                  <polygon
                    points="0 0, 10 3.5, 0 7"
                    fill="#6b7280"
                  />
                </marker>
              </defs>
            </svg>

            {/* Nodes */}
            {nodes.map(node => {
              const nodeConfig = nodeTypes[node.type];
              const isSelected = selectedNode?.id === node.id;
              
              return (
                <div
                  key={node.id}
                  data-node-id={node.id}
                  className={`absolute pointer-events-auto select-none transition-all rounded-lg ${
                    isSelected ? 'ring-2 ring-blue-500 dark:ring-blue-400 ring-offset-0' : ''
                  } ${isDragging === node.id ? 'cursor-grabbing' : 'cursor-grab'}`}
                  style={{
                    left: node.position.x,
                    top: node.position.y,
                    zIndex: 2
                  }}
                  onMouseDown={(e) => handleNodeMouseDown(e, node.id)}
                >
                  {/* <div className={`w-24 h-16 rounded-lg border-2 border-white shadow-lg flex flex-col items-center justify-center text-white ${nodeConfig.color}`}>
                    <span className="text-xs font-medium truncate px-1">{node.data.label}</span>
                  </div> */}

                  {/* Updated: [16-06-2025] v0.1.3 */}
                  {node.type === 'decision' ? (
                    // Diamond shape for decision nodes
                    <div className="relative w-24 h-16 flex items-center justify-center">
                      <svg width="96" height="64" className="absolute inset-0">
                        <polygon
                          points="48,4 88,32 48,60 8,32"
                          fill="rgb(234 179 8)"
                          stroke="white"
                          strokeWidth="2"
                          className="drop-shadow-lg"
                        />
                      </svg>
                      <div className="relative z-10 flex flex-col items-center justify-center text-white dark:text-gray-900">
                        <span className="text-xs font-medium truncate px-1 max-w-16 text-center">{node.data.label}</span>
                      </div>
                    </div>
                  ) : (
                    // Rectangle shape for other nodes
                    <div className={`w-24 h-16 rounded-lg border-2 border-white dark:border-gray-900 shadow-lg flex flex-col items-center justify-center text-white dark:text-gray-900 ${nodeConfig.color}`}>
                      <span className="text-xs font-medium truncate px-1">{node.data.label}</span>
                    </div>
                  )}
                  
                  {isSelected && (
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        deleteNode(node.id);
                      }}
                      className="absolute -top-2 -right-2 w-6 h-6 bg-red-500 text-white rounded-full flex items-center justify-center hover:bg-red-600 transition-colors"
                    >
                      <TrashBinIcon className="w-3 h-3" />
                    </button>
                  )}
                </div>
              );
            })}
          </div>
        </div>

        {/* Configuration Panel */}
        <div className="w-80 bg-white dark:bg-gray-800 border-l border-gray-200 dark:border-gray-700 p-4 rounded-r-2xl">
          <div className="flex items-center gap-2 mb-2">
            <PencilIcon className="w-5 h-5 text-lg font-semibold text-gray-700 dark:text-gray-200" />
            <h3 className="text-lg font-semibold text-gray-700 dark:text-gray-200">Node Configuration</h3>
          </div>

          {/* Updated: [16-06-2025] v0.1.3 */}
          {/* Validation Errors */}
          {validationErrors.length > 0 && (
            // <div className="mb-4 p-3 bg-red-100 dark:bg-red-800 border border-red-200 dark:border-red-700 rounded-lg">
            //   <h4 className="text-sm font-medium text-red-800 dark:text-red-100 mb-2">Validation Errors:</h4>
            //   <ul className="text-xs text-red-700 dark:text-red-200 space-y-1">
            //     {validationErrors.map((error, index) => (
            //       <li key={index}>• {error}</li>
            //     ))}
            //   </ul>
            // </div>

            <Alert
              variant="error"
              title="Validation Errors"
              messages={validationErrors}
              showLink={false}
            />
          )}

          {selectedNode ? (
            <div className="space-y-2">
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-200 mb-1">
                  Label
                </label>
                <Input
                  type="text"
                  value={selectedNode.data.label}
                  onChange={(e) => updateNodeData(selectedNode.id, { label: e.target.value })}
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-200 mb-1">
                  Description
                </label>
                <TextArea
                  value={selectedNode.data.description || ''}
                  // onChange={(e) => updateNodeData(selectedNode.id, { description: e.target.value })}
                  onChange={(value) => updateNodeData(selectedNode.id, { description: value })}
                  rows={3}
                  placeholder="Enter description..."
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-200 mb-1">
                  Node Type
                </label>
                <div className="flex items-center gap-2 p-2 bg-gray-200 dark:bg-gray-700 rounded-lg">
                  <span className="text-sm font-medium text-gray-900 dark:text-white">{nodeTypes[selectedNode.type].label}</span>
                </div>
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-200 mb-1">
                  Position
                </label>
                <div className="grid grid-cols-2 gap-2">
                  <div>
                    <label className="block text-xs text-gray-500 dark:text-gray-400">X</label>
                    {/*
                    <input
                      type="number"
                      value={Math.round(selectedNode.position.x)}
                      onChange={(e) => {
                        const newNodes = nodes.map(n => 
                          n.id === selectedNode.id 
                            ? { ...n, position: { ...n.position, x: parseInt(e.target.value) || 0 } }
                            : n
                        );
                        setNodes(newNodes);
                        setSelectedNode({ ...selectedNode, position: { ...selectedNode.position, x: parseInt(e.target.value) || 0 } });
                      }}
                      className="w-full px-2 py-1 border border-gray-300 dark:border-gray-600 rounded focus:ring-1 focus:ring-blue-500 dark:focus:ring-blue-400 text-gray-900 dark:text-white bg-white dark:bg-gray-900"
                    />
                    */}
                    {/* Updated: [12-06-2025] v0.1.1 */}
                    <Input
                      type="number"
                      value={Math.round(selectedNode.position.x)}
                      onChange={(e) => {
                        const newPosition = snapToGrid({ 
                          x: parseInt(e.target.value) || 0, 
                          y: selectedNode.position.y 
                        });
                        const newNodes = nodes.map(n => 
                          n.id === selectedNode.id 
                            ? { ...n, position: newPosition }
                            : n
                        );
                        setNodes(newNodes);
                        setSelectedNode({ ...selectedNode, position: newPosition });
                      }}
                      step={GRID_SIZE}
                    />
                  </div>
                  <div>
                    <label className="block text-xs text-gray-500 dark:text-gray-400">Y</label>
                    {/*
                    <input
                      type="number"
                      value={Math.round(selectedNode.position.y)}
                      onChange={(e) => {
                        const newNodes = nodes.map(n => 
                          n.id === selectedNode.id 
                            ? { ...n, position: { ...n.position, y: parseInt(e.target.value) || 0 } }
                            : n
                        );
                        setNodes(newNodes);
                        setSelectedNode({ ...selectedNode, position: { ...selectedNode.position, y: parseInt(e.target.value) || 0 } });
                      }}
                      className="w-full px-2 py-1 border border-gray-300 dark:border-gray-600 rounded focus:ring-1 focus:ring-blue-500 dark:focus:ring-blue-400 text-gray-900 dark:text-white bg-white dark:bg-gray-900"
                    />
                    */}
                    {/* Updated: [12-06-2025] v0.1.1 */}
                    <Input
                      type="number"
                      value={Math.round(selectedNode.position.y)}
                      onChange={(e) => {
                        const newPosition = snapToGrid({ 
                          x: selectedNode.position.x, 
                          y: parseInt(e.target.value) || 0 
                        });
                        const newNodes = nodes.map(n => 
                          n.id === selectedNode.id 
                            ? { ...n, position: newPosition }
                            : n
                        );
                        setNodes(newNodes);
                        setSelectedNode({ ...selectedNode, position: newPosition });
                      }}
                      step={GRID_SIZE}
                    />
                  </div>
                </div>
              </div>

              {/* Type-specific configuration */}
              {selectedNode.type === 'decision' && (
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-200 mb-1">
                    Condition
                  </label>
                  <Input
                    type="text"
                    value={typeof selectedNode.data.config?.condition === 'string' ? selectedNode.data.config.condition : ''}
                    onChange={(e) => updateNodeData(selectedNode.id, { 
                      config: { ...(selectedNode.data.config ?? {}), condition: e.target.value }
                    })}
                    placeholder="Enter condition..."
                  />
                </div>
              )}

              {selectedNode.type === 'process' && (
                // <div>
                //   <label className="block text-sm font-medium text-gray-700 dark:text-gray-200 mb-1">
                //     Action
                //   </label>
                //   <Select
                //     options={actionOptions}
                //     placeholder="Select Action"
                //     onChange={(e) => updateNodeData(selectedNode.id, {
                //       config: {
                //         ...selectedNode.data.config,
                //         action: e.target.value,
                //       }
                //     })}
                //     className="bg-white dark:bg-gray-900"
                //     defaultValue={typeof selectedNode.data.config?.action === 'string' ? selectedNode.data.config.action : ''}
                //   />
                // </div>

                // Updated: [16-06-2025] v0.1.3
                <>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-200 mb-1">
                      Action
                    </label>
                    <Select
                      options={actionOptions}
                      placeholder="Select Action"
                      // onChange={(e) => updateNodeData(selectedNode.id, {
                      //   config: { ...selectedNode.data.config, action: e.target.value }
                      // })}
                      onChange={(value) => updateNodeData(selectedNode.id, {
                        config: { ...selectedNode.data.config, action: value }
                      })}
                      className="bg-white dark:bg-gray-900"
                      // defaultValue={typeof selectedNode.data.config?.action === 'string' ? selectedNode.data.config.action : ''}
                      value={typeof selectedNode.data.config?.action === 'string' ? selectedNode.data.config.action : ''}
                    />
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-200 mb-1">
                      Form
                    </label>
                    <Select
                      options={formOptions}
                      placeholder="Select Form"
                      // onChange={(e) => updateNodeData(selectedNode.id, { 
                      //   config: { ...selectedNode.data.config, form: e.target.value }
                      // })}
                      onChange={(value) => updateNodeData(selectedNode.id, { 
                        config: { ...selectedNode.data.config, form: value }
                      })}
                      className="bg-white dark:bg-gray-900"
                      // defaultValue={typeof selectedNode.data.config?.form === 'string' ? selectedNode.data.config.form : ''}
                      value={typeof selectedNode.data.config?.form === 'string' ? selectedNode.data.config.form : ''}
                    />
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      SLA (Hours)
                    </label>
                    <Input
                      type="number"
                      value={typeof selectedNode.data.config?.sla === 'string' || typeof selectedNode.data.config?.sla === 'number' ? selectedNode.data.config.sla : ''}
                      onChange={(e) => updateNodeData(selectedNode.id, { 
                        config: { ...selectedNode.data.config, sla: e.target.value }
                      })}
                      placeholder="Enter SLA in hours..."
                      min="1"
                      max="720"
                    />
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      PIC (Person in Charge)
                    </label>
                    <Select
                      options={PICOptions}
                      placeholder="Select PIC"
                      // onChange={(e) => updateNodeData(selectedNode.id, { 
                      //   config: { ...selectedNode.data.config, pic: e.target.value }
                      // })}
                      onChange={(value) => updateNodeData(selectedNode.id, { 
                        config: { ...selectedNode.data.config, pic: value }
                      })}
                      className="bg-white dark:bg-gray-900"
                      // defaultValue={typeof selectedNode.data.config?.pic === 'string' ? selectedNode.data.config.pic : ''}
                      value={typeof selectedNode.data.config?.pic === 'string' ? selectedNode.data.config.pic : ''}
                    />
                  </div>
                </>
              )}

              {/* Updated: [16-06-2025] v0.1.3 */}
              {/* Connection Info */}
              <div className="pt-4 border-t border-gray-200">
                <h4 className="text-sm font-medium text-gray-700 dark:text-gray-200 mb-2">Connections</h4>
                <div className="text-xs text-gray-600 dark:text-gray-300 space-y-1">
                  <div>
                    Outgoing: {connections.filter(c => c.source === selectedNode.id).length}
                    {selectedNode.type === 'decision' && ' / 2 (Yes/No)'}
                    {selectedNode.type !== 'decision' && ' / 1'}
                  </div>
                  <div>Incoming: {connections.filter(c => c.target === selectedNode.id).length}</div>
                </div>
              </div>
            </div>
          ) : (
            <div className="text-center text-gray-600 dark:text-gray-300 py-8">
              <PencilIcon className="w-12 h-12 mx-auto mb-2 opacity-30" />
              <p>Select a node to configure its properties</p>
            </div>
          )}

          {/* Workflow Stats */}
          <div className="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
            <h4 className="text-sm font-medium text-gray-700 dark:text-gray-200 mb-2">Workflow Stats</h4>
            <div className="text-xs text-gray-600 dark:text-gray-300 space-y-1">
              {/* Updated: [12-06-2025] v0.1.2 */}
              <div>Title: <span className="font-medium">{workflowMetadata.title}</span></div>
              <div>Status: <span className={`px-1 py-0.5 rounded text-xs ${
                  workflowStatuses.find(s => s.value === workflowMetadata.status)?.color || 'text-gray-600 dark:text-gray-300 bg-gray-100 dark:bg-gray-900'
                }`}>
                  {workflowStatuses.find(s => s.value === workflowMetadata.status)?.label}
                </span>
              </div>
              <div>Nodes: {nodes.length}</div>
              <div>Connections: {connections.length}</div>
              
              {/* Updated: [16-06-2025] v0.1.3 */}
              <div>Start Nodes: {nodes.filter(n => n.type === 'start').length}</div>
              <div>End Nodes: {nodes.filter(n => n.type === 'end').length}</div>
            </div>
          </div>
        </div>

        {/* Updated: [12-06-2025] v0.1.1 */}
        {/* JSON Preview Dialog */}
        {showJsonPreview && (
          <Modal isOpen={showJsonPreview} onClose={() => setShowJsonPreview(false)} className="max-w-4xl p-6">
            <div className="flex items-center justify-between p-4">
              <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-100">Workflow JSON Preview</h3>
              <p className="text-sm text-gray-600 dark:text-gray-300">{workflowMetadata.title}</p>
            </div>
            
            <div className="p-4 overflow-auto max-h-[60vh]">
              <pre className="bg-white dark:bg-gray-900 p-4 rounded-lg text-sm overflow-auto text-gray-800 dark:text-gray-100">
                {/* {JSON.stringify({ nodes, connections }, null, 2)} */}
                {/* Updated: [12-06-2025] v0.1.2 */}
                {JSON.stringify({ 
                  nodes, 
                  connections, 
                  metadata: {
                    ...workflowMetadata,
                    updatedAt: new Date().toISOString()
                  }
                }, null, 2)}
              </pre>
            </div>
            
            <div className="flex items-center justify-end gap-2 p-4">
              {/* Updated: [16-06-2025] v0.1.3 */}
              <Button
                onClick={copyJsonToClipboard}
                variant={`${
                  copiedJson 
                    ? 'success' 
                    : 'outline'
                }`}
              >
                {copiedJson ? <CheckLineIcon className="w-4 h-4" /> : <CopyIcon className="w-4 h-4" />}
                {copiedJson ? 'Copied!' : 'Copy JSON'}
              </Button>

              <Button
                onClick={() => setShowJsonPreview(false)}
                variant="outline"
              >
                Cancel
              </Button>
              <Button
                onClick={saveWorkflow}
                disabled={validationErrors.length > 0}
                variant={`${
                  validationErrors.length > 0
                    ? 'outline'
                    : 'primary'
                }`}
              >
                <DownloadIcon className="w-4 h-4" />
                Save Workflow
              </Button>
            </div>
          </Modal>
        )}
      </div>
    </>
  );
};

export default WorkflowVisualEditor;

/**
 * @keyFeatures
 * ----------------------------------------------------------------------------
 * - Visual Canvas.
 * - Node Types.
 * - Real-time Editing.
 * - Type-specific Config.
 * - Position Control.
 * - Delete Functionality.
 * - Visual Feedback.
 * 
 * @version 0.1.0
 * @date    11-06-2025
 * ----------------------------------------------------------------------------
 * - Grid Alignment for Nodes.
 * - Grid Alignment for Connections.
 * - Border-Aware Connections.
 * - JSON Preview Dialog.
 * 
 * @version 0.1.1
 * @date    12-06-2025
 * ----------------------------------------------------------------------------
 * Metadata:
 * - Workflow Title Input.
 * - Workflow Description Input.
 * - Workflow Status Selector.
 * 
 * @version 0.1.2
 * @date    12-06-2025
 * ----------------------------------------------------------------------------
 * - URL-based JSON Loading.
 * - Copy JSON Button.
 * - Enhanced Node Connectors.
 * - Start/End Node Validation.
 * - Enhanced Process Node Configuration.
 * - Diamond-Shaped Decision Nodes.
 * - Yes/No Decision Connectors.
 * - Connection Limits & Validation.
 * 
 * @version 0.1.3
 * @date    16-06-2025
 * ----------------------------------------------------------------------------
 */
